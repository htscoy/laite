import{eventHandler as f,toWebRequest as d}from"@tanstack/start-server-core";const P=[{path:"/__root",filePath:"/Users/hetenho/own/laite-app/src/routes/__root.tsx"},{path:"/",filePath:"/Users/hetenho/own/laite-app/src/routes/index.tsx"},{path:"/settings",filePath:"/Users/hetenho/own/laite-app/src/routes/settings.tsx"},{path:"/_pathlessLayout/_nested-layout",filePath:"/Users/hetenho/own/laite-app/src/routes/_pathlessLayout/_nested-layout.tsx"},{path:"/api/users/:$id?",filePath:"/Users/hetenho/own/laite-app/src/routes/api/users.$id.ts",$APIRoute:{src:"src/routes/api/users.$id.ts?pick=APIRoute",build:()=>import("../users._id.js"),import:()=>import("../users._id.js")}},{path:"/api/users",filePath:"/Users/hetenho/own/laite-app/src/routes/api/users.ts",$APIRoute:{src:"src/routes/api/users.ts?pick=APIRoute",build:()=>import("../users.js"),import:()=>import("../users.js")}},{path:"/_pathlessLayout/_nested-layout/route-a",filePath:"/Users/hetenho/own/laite-app/src/routes/_pathlessLayout/_nested-layout/route-a.tsx"},{path:"/_pathlessLayout/_nested-layout/route-b",filePath:"/Users/hetenho/own/laite-app/src/routes/_pathlessLayout/_nested-layout/route-b.tsx"}],m=["GET","POST","PUT","PATCH","DELETE","OPTIONS","HEAD"];function _(t){return f(async o=>{const r=d(o);return await t({request:r})})}const g=t=>o=>({path:t,methods:o});function R(t,o){const r=t.pathname.split("/").filter(Boolean),i=o.sort((s,e)=>{const a=s.routePath.split("/").filter(Boolean);return e.routePath.split("/").filter(Boolean).length-a.length}).filter(s=>{const e=s.routePath.split("/").filter(Boolean);return r.length>=e.length});for(const s of i){const e=s.routePath.split("/").filter(Boolean),a={};let n=!0;for(let l=0;l<e.length;l++){const p=e[l],h=r[l];if(p.startsWith("$"))if(p==="$"){const u=r.slice(l).join("/");if(u!=="")a["*"]=u,a._splat=u;else{n=!1;break}}else{const u=p.slice(1);a[u]=h}else if(p!==h){n=!1;break}}if(n)return{routePath:s.routePath,params:a,payload:s.payload}}}const c=P.filter(t=>t.$APIRoute);function w(t){const o=[];return t.forEach(r=>{const s=r.path.split("/").filter(Boolean).map(e=>e==="*splat"?"$":e.startsWith(":$")&&e.endsWith("?")?e.slice(1,-1):e).join("/");o.push({routePath:`/${s}`,payload:r})}),o}const I=async({request:t})=>{if(!c.length)return new Response("No routes found",{status:404});if(!m.includes(t.method))return new Response("Method not allowed",{status:405});const o=w(c),r=new URL(t.url,"http://localhost:3000"),i=R(r,o);if(!i)return new Response("Not found",{status:404});let s;try{s=await i.payload.$APIRoute.import().then(n=>n.APIRoute)}catch(n){return console.error("Error importing route file:",n),new Response("Internal server error",{status:500})}if(!s)return new Response("Internal server error",{status:500});const e=t.method,a=s.methods[e];return a?await a({request:t,params:i.params}):new Response("Method not allowed",{status:405})};export{g as a,_ as c,I as d};
